/*
Название программы: Graf10

Назначение программы: находить путь передачи книги так,
чтобы она была у всех в руках и вернулась владельцу.

Назначение файла: создать смежную матрицу и найти путь книги.

Файл Graf10.c является заголовочным для этого файла.

Автор: Власов Евгений ИВТ-13БО
*/

#include <stdio.h>
#include <locale.h>
#define _CRT_SECURE_NO_WARNINGS
#define N 100

//Создание смежной матрицы.
int* CreateAndCheckAdjacentMatrix(int A[N][N], int n)
{
	// f - числа в матрице (0 - враги (нет связи), 1 - друзья (связь есть)).
	// k - коэффициент связей (при чётном N k = N/2; при нечётном N k = 0).
	int f, k = 0;
	//Создание смежной матрицы.
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < n; j++)
		{
			//Заполнение диагонали смежной матрицы нулями.
			if (i == j)
			{
				A[i][j] = 0;
				continue;
			}
			//Если параллельный относительно главной диагонали элемент
			//смежной матрицы уже есть, то пропустить шаг цикла.
			if (A[j][i] == 0 || A[j][i] == 1)
				continue;
			//Вывод столбца и строки смежной матрицы, чтобы пользователь ввёл число 0 или 1.
			printf_s("\n[%d][%d] -> ", i, j);
			//Считывание введённого числа и его проверка.
			if (!scanf_s("%d", &f)) {
				printf_s("This is not number\n");
				system("pause");
				exit(0);
			}
			if (!(f == 1 || f == 0)) {
				printf_s("Wrong number\n");
				system("pause");
				exit(0);
			}
			//Если связь есть, то к стан. больше на 1, иначе убавляется 1.
			if (f == 1)
				k++;
			else
				k--;
			//Заполняем симметричный относитеьно главной диагонали элемент смежной матрицы.
			A[i][j] = f;
			A[j][i] = f;
		}
	}
	//Проверка на правильность ввода матрицы.
	//Матрица смежности неверна, если:
	//при чётном N k не равно N/2; при нечётном N k не равно 0.
	if (n % 2 == 0 && k != n / 2) {
			printf_s("Wrong matrix\n");
			system("pause");
			exit(0);
	}
	if (n % 2 != 0 && k != 0) {
			printf_s("Wrong matrix\n");
			system("pause");
			exit(0);
	}
	//Функция возвращает матрицу смежности.
	return A;
}

//Нахождение пути книги
int FindingPaths(int A[N][N], int n)
{
	//i, j - столбец и строка смежной матрицы, l - кол-во пройденных путей (нужна чтобы замкнуть круг).
	int i = 0, j = 0, l = 0;
	//Вспомогательная матрица. Нужна чтобы пометить уже пройденные пути.
	int B[N];
	//Инициализация вспомогательной матрицы.
	for (int i = 0; i < n; i++) {
		B[i] = 0;
	}
	//Нахождение путей книги.
	for (j; l < n - 1; j++) {
		//Если связь есть.
		if (A[i][j] == 1) {
			//Помечаем пройденный путь.
			B[i] = i;
			//Если путь ещё не исп., то вывод пути, 
			//переход на параллельный главной диагонали смежной матрицы элемент,
			//переход в начало строки(в начале следующего цикла j = 0) 
			//и пометка, что путь найден.
			if (j != B[j]) {
				printf_s("{%d;%d}->", i, j);
				i = j;
				j = -1;
				l++;
			}
		}
	}
	//После того, как круг пройден, замыкаем круг.
	j = 0;
	printf_s("{%d;%d}\n", i, j);
	return 0;
}
